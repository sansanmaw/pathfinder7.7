# -*- coding: utf-8 -*-
"""Final Project (Disaster Relief Management System).ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1S_QAsrLISqHN46tFX8BOHdXu_QzwFBfd

**Disaster Relief Resource Management System**

Our goal is to build a program to manage donated resources and distribute them based on urgency and location using below data structures:

(1) Linked List for tracking donations

(2) Priority Queue (from Queue) for relief area prioritization

(3) Dijkstra Algorithm for finding the shortest path from a store house (starting point) to a disaster location

After the catastrophic 7.7 magnitude earthquake in Myanmar on March 28, 2025, citizens, NGOs, and volunteers responded with immense generosity. But without coordination, even the best intentions can lead to chaos. This project simulates a structured resource distribution system using core data structures to optimize disaster relief delivery.

**Main Functionalities**

1.   Add donation            (Singly Linked List)
2.   Remove donation         (Singly Linked List)
3.   Report Disaster         (Priority Queue)
4.   Distribute Supplies     (Priority Queue + Singly Linked List)
5.   View Supplies           (Singly Linked List)
6.   Dijkstra's Algorithm (Shortest Path Algorithm)

**(1) Add donation (2) Remove donation (5) View Supplies (With Error Handling)**
"""

class DonationNode:
    def __init__(self, name, location, item, amount, urgency):
        self.name = name #Donor's name
        self.location = location #Donation Location
        self.item = item #Items to donate
        self.amount = amount #Amount of items
        self.urgency = urgency #Urgency level (1=highest, 5=lowest)
        self.next = None


class DonationList:
    def __init__(self):
        self.head = None #Start with an empty donation list

    def append(self, name, location, item, amount, urgency):
        #Error handling for invalid inputs
        if name == "" or location == "" or item == "": #If name, location and item are empty,
            print("Name, location, and item should not be empty.") #It will print this
            return
        try:
            amount = int(amount) #Convert amount to integer if accidently fill as words
            urgency = int(urgency) #Convert urgency to integer
        except ValueError:
            print("Amount and urgency are supposed to be numbers.")
            return

        if amount <= 0: #Amount must be 0 or larger than zero
            print("Amount must be greater than 0.")
            return
        if urgency < 1 or urgency > 5: #Urgency must be between 1 and 5
            print("Urgency must be between 1 and 5.")
            return

        new_node = DonationNode(name, location, item, amount, urgency)

        if self.head is None: #If list is empty,
            self.head = new_node #Create new node
            print(f"Added {name} at {location}: {amount} x {item} (Urgency: {urgency})")
            return

        last = self.head #Start at the head
        while last.next: #Traverse to last node
            last = last.next
        last.next = new_node #Add new node at the end
        print(f"Added {name} at {location}: {amount} x {item} (Urgency: {urgency})")

    #delete by name
    def delete(self, name):
        if not self.head:
            print("The list is empty.")
            return

        current = self.head  #Start from the head
        prev = None

        if current.name.lower() == name.lower(): #If current head is the node to delete
            self.head = current.next #Move head to next node
            print(f"Deleted '{name}' from the list.")
            return

        while current: #Loop through the list till the end
            if current.name.lower() == name.lower():
                prev.next = current.next #Skip over the current node by linking the previous node to the next one
                print(f"Deleted '{name}' from the list.")
                return
            prev = current #Move previous forward to current node
            current = current.next #Move current forward to next node

        print("Item not found.")

    def print_list(self):
        current = self.head
        if not current:
            print("No supplies available.")
            return

        print("\n Current Donations:")
        while current:
            print(f"- {current.name} | {current.amount}x {current.item} | Urgency: {current.urgency} | Location: {current.location}")
            current = current.next

#Test cases for function1,2,5 (Add donations, Delete donation, View Supplies)
donation_list = DonationList()

donation_list.append("UNICEF", "Yangon", "Water Bottles", 5000, 2)
donation_list.append("Red Cross", "Mandalay", "Medical Supplies", 10000, 1)
donation_list.append("Local Group", "Naypyidaw", "Blankets", 1000, 3)

donation_list.print_list()

donation_list.delete("Red Cross")

#Print list again after deletion
donation_list.print_list()

#Test invalid entries
donation_list.append("", "Yangon", "Food", 30, 2) #Missing name
donation_list.append("Volunteer", "", "Clothing", 20, 2) #Missing location
donation_list.append("Helper", "Sagaing", "Shelter", "ten", 3) #Invalid amount
donation_list.append("NGO", "Magway", "First Aids Kits", 100, 6) #Urgency out of range

"""**(3) Disaster Reporting Using PriorityQueue**"""

from queue import PriorityQueue #Take a reference from in-class practice

class AidRequestQueue:
    def __init__(self): #Initializes the class
        self.queue = PriorityQueue() #Create priority queue to store

    def report_request(self, location, urgency):
        try:
            urgency = int(urgency) #Urgency is converted to an integer because the request was stored as tuple (location, urgency)
            if urgency < 1 or urgency > 5:
                print("Urgency must be between 1 (frist priority) and 5 (fifth priority).")
                return

            self.queue.put((urgency, location))
            print(f"Reported aid request at {location} with urgency {urgency}.")
        except ValueError:
            print("Urgency must be a number.")

    def get_next_request(self):
        if self.queue.empty():
            print("No disasters reported.")
            return None
        return self.queue.get()

    def is_empty(self):
        return self.queue.empty()


#Test Case
aid_queue = AidRequestQueue()

#Report valid requests
aid_queue.report_request("Yangon", 2)
aid_queue.report_request("Mandalay", 1)
aid_queue.report_request("Naypyidaw", 3)

#Report invalid urgency
aid_queue.report_request("Bago", 0)
aid_queue.report_request("Myitkyina", 6)

#Report non-numeric urgency
aid_queue.report_request("Taunggyi", "urgent")

#Retrieve aid requests in priority order
print("\nGetting aid requests by urgency:")
while not aid_queue.is_empty():
    urgency, location = aid_queue.get_next_request()
    print(f"Dispatching aid to {location} (Urgency: {urgency})")

#Try retrieving from an empty queue
aid_queue.get_next_request()

"""(4) **Distribute Supplies**"""

def distribute_supplies(donations, aid_requests): #two things to ask (donations and aid_request)
    if aid_requests.is_empty():
        print("No aid requests to proceed.")
        return

    if donations.head is None: #If donation list is empty, its head is none.
        print("No donations available.") #So, no donations is available.
        return
    #If donation is available,
    request = aid_requests.get_next_request() #request aid based on priority
    urgency = request[0] #access first element at index 0
    location = request[1] #access second element at index 1
    print(f"\nDistributing supplies to: {location} (Urgency: {urgency})")

    current = donations.head #Now, take first available donation
    if current: #If current is not none,
        print(f"Sending {current.amount} items from {current.name} to {location}.") #Print supplies with (current.amount) taken from donor's name to requested location
        donations.head = current.next #Move head to next donation
    else:
        print("No donations available to send.")

#Test Case
donations = DonationList()
donations.append("PARAMI", "Sagaing", "Mosquito Net", 500, 3)

aid_requests = AidRequestQueue()
aid_requests.report_request("Sagaing", 1)


distribute_supplies(donations, aid_requests)
distribute_supplies(donations, aid_requests)

"""**(6) Dijkstra's Algorithm (Shortest Path Algorithm)**"""

def dijkstra(graph, start):
#Nodes=locations (cities, disaster sites)
#Edges=paths with weights
    distances = {node: float('inf') for node in graph} #First, all distance are infinity as they are unknown.
    distances[start] = 0 #Starting point has zero distance.
    visited = set() #To list visited nodes like this {Sagaing, Mandalay, Naypyidaw, Yangon}

    while len(visited) < len(graph): #loop all nodes to be visited
        min_node = None
        min_distance = float('inf')
        #Find shortest distance
        for node in graph:
            if node not in visited and distances[node] < min_distance:
                min_node = node #If there is a minimum node,
                min_distance = distances[node] #Shortest distance is found

        if min_node is None: #no more reachable nodes
            break

        visited.add(min_node) #Will add to visited list
#Check and update distances for neighboring nodes
        for neighbor, weight in graph[min_node]:
            if neighbor not in visited: #If neighbor not visited
                new_distance = distances[min_node] + weight #Total distance through current node
                if new_distance < distances[neighbor]:
                    distances[neighbor] = new_distance  #Update if shorter path is found

    return distances

#Test Case
graph = {
    "Yangon": [("Bago", 2), ("Pathein", 5)],
    "Bago": [("Naypyidaw", 4)],
    "Pathein": [("Naypyidaw", 6)],
    "Naypyidaw": [("Mandalay", 3)],
    "Mandalay": [("Sagaing", 2)],
    "Sagaing": []
}
start_location = "Yangon"
result = dijkstra(graph, start_location)

print(f"Shortest distances from {start_location}:")
for location, distance in result.items():
    print(f"{location}: {distance}")

"""Interactive Menu"""

def menu():
   #Initializing empty list and queue
    donations = DonationList()
    aid_requests = AidRequestQueue()

#Graph to show locatons and distance
    graph = {
        "Yangon": [("Bago", 2), ("Pathein", 5)],
        "Bago": [("Naypyidaw", 4)],
        "Pathein": [("Naypyidaw", 6)],
        "Naypyidaw": [("Mandalay", 3)],
        "Mandalay": [("Sagaing", 2)],
        "Sagaing": []
    }
#Traverse to keep the program running until the user chooses to exit
    while True:
        print("\n  Project Pathfinders 7.7")
        print("1. Donate Supplies")
        print("2. Report Disaster")
        print("3. Distribute Supplies")
        print("4. View All Donations")
        print("5. Shortest Paths")
        print("6. Exit")
        choice = input("Choose an option (1-6): ") #Asking to add input

        if choice == '1': #Choice 1 is to add a donation to Linked List
            name = input("Donor name: ")
            location = input("Destination location (where items will be sent): ")
            item = input("Item: ")
            amount = input("Amount: ")
            urgency = input("Urgency (1-5): ")
            donations.append(name, location, item, amount, urgency)

        elif choice == '2': #Choice 2 is to add a disaster aid request to the priority queue
            location = input("Disaster location: ")
            urgency = input("Urgency (1-5): ")
            aid_requests.report_request(location, urgency)

        elif choice == '3': #Distribute all current donations
            distribute_supplies(donations, aid_requests, graph)

        elif choice == '4': #Print all current locations
            donations.print_list()

        elif choice == '5': #Choice 5 is to find and print the shorest paths from a selected starting location
            start = input("Enter starting location for shortest path: ")
            if start not in graph:
                print("Invalid location.")
            else:
                distances = dijkstra(graph, start) #Call dijkstra algorithms, and pass graph and start
                print(f"\nShortest paths from {start}:") #Will print shortest path
                for location, distance in distances.items(): #This will loop through each location and its shortest distance
                    dist_text = distance if distance != float('inf') else 'Not Reachable'
                    print(f"- {location}: {dist_text}")

        elif choice == '6': #Exit the program
            print("Exit")
            break

        else:
            print("Invalid option")
menu()

"""Time Complexity"""

def add_n_donations(n):
    dl = DonationList() #Empty list
    for i in range(n): #Applying for loop repeating n times
        dl.append(f"Donor{i}", "City", f"Item{i}", 1, 3)
    return dl #print donation list

import time
n = 50 #Number of donations
start = time.time()
donations = add_n_donations(n) #O(n)
end = time.time()
print(f"Time to append {n} donations: {end - start:.4f} seconds")

donations.delete("Donor0") #Deleting Head node
donations.delete(f"Donor{n-1}") #Deleting last node, O(n)
end = time.time()
print(f"Time to delete 2 nodes: {end - start:.4f} seconds")

donations.print_list() #printing all existing nodes in the linked list
end = time.time()
print(f"Time to print list: {end - start:.4f} seconds")

def requests(n):
    aid_queue = AidRequestQueue() #Empty aid request priority queue
    for i in range(n):
        aid_queue.report_request(f"Location{i}", (i % 5) + 1) #Using % operator for generator urgency level so that we can avoid adding manually
    return aid_queue

n = 50 #number of requests
start = time.time()
aid_queue = requests(n) #O(log n)
end = time.time()
print(f"\nTime to report {n} aid requests: {end - start:.4f} seconds")

start = time.time()
count = 0 #starting a counter
while not aid_queue.is_empty():
    aid_queue.get_next_request() #O(log n)
    count += 1 #process the request count
end = time.time()
print(f"Time to process {count} aid requests (get_next_request): {end - start:.4f} seconds")

def measure_dijkstra_time(graph, start):
    start_time = time.time()
    distances = dijkstra(graph, start) #O(nÂ²)
    end_time = time.time()
    print(f"Time to run Dijkstra's algorithm: {end_time - start_time:.6f} seconds")
    return distances
distances = measure_dijkstra_time(graph, start_location)